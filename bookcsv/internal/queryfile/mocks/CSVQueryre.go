// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "context"
import mock "github.com/stretchr/testify/mock"
import queryfile "github.com/Deny7676yar/Go_level2/bookcsv/internal/queryfile"

// CSVQueryre is an autogenerated mock type for the CSVQueryre type
type CSVQueryre struct {
	mock.Mock
}

// DeleteEntry provides a mock function with given fields: ctx, key, data
func (_m *CSVQueryre) DeleteEntry(ctx context.Context, key string, data []queryfile.Entry) error {
	ret := _m.Called(ctx, key, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []queryfile.Entry) error); ok {
		r0 = rf(ctx, key, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Insert provides a mock function with given fields: ctx, pS, data
func (_m *CSVQueryre) Insert(ctx context.Context, pS *queryfile.Entry, data []queryfile.Entry) error {
	ret := _m.Called(ctx, pS, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *queryfile.Entry, []queryfile.Entry) error); ok {
		r0 = rf(ctx, pS, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveCSVFile provides a mock function with given fields: ctx, filepath, data
func (_m *CSVQueryre) SaveCSVFile(ctx context.Context, filepath string, data []queryfile.Entry) error {
	ret := _m.Called(ctx, filepath, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []queryfile.Entry) error); ok {
		r0 = rf(ctx, filepath, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Search provides a mock function with given fields: ctx, key, data
func (_m *CSVQueryre) Search(ctx context.Context, key string, data []queryfile.Entry) *queryfile.Entry {
	ret := _m.Called(ctx, key, data)

	var r0 *queryfile.Entry
	if rf, ok := ret.Get(0).(func(context.Context, string, []queryfile.Entry) *queryfile.Entry); ok {
		r0 = rf(ctx, key, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*queryfile.Entry)
		}
	}

	return r0
}

// Select provides a mock function with given fields: ctx, data
func (_m *CSVQueryre) Select(ctx context.Context, data []queryfile.Entry) {
	_m.Called(ctx, data)
}
